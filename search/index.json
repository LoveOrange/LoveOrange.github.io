[{"content":"在 2025 年 5 月 30 日这一天，我经历了获取驾照十年以来，第一次交通事故。\n事故本身没什么说的，我直行，对方向左侧并道。我的右前侧与对方左前侧相撞。很清晰的事故，对方全责，没有任何异议。\n我曾经想过无数发生事故的场景，有的对方死不认账，有的下来就开始吵架。结果第一次遇到事故，就遇到了一个“意料之外”的大哥。\n大哥看上去老老实实，年龄偏大，没有被撞了生气的样子，只是不停的重复“哎呀，你让我一下就不会撞到了”，相比埋怨，更多的可能还是无奈与可惜。运营车辆，车上的乘客只能慢慢的走下高架，不知道还能不能赶上一会儿的火车。\n我承认我是一个有“路怒症”的人，相撞的第一时间也确实生气。不过看到对方如此的“老实”，反而让我生不起气来了，甚至有些觉得自己是一个不再可爱的反派角色。过于丰富的想象力，让我为对方设计了一个用户画像：全职的网约车司机，并不富裕的经济状况，一个为了家人、生活而奋斗的普通人。好吧，也许有些多愁善感了，但是此时我的情绪可能更多的就是：\n难过。\n我一直认为，人要坚定不移地坚持自己认为正确的事情。我也总说，最讨厌的人就是不遵守交通规则的人。然而当我坚持了自己的“正义”，遵守了交通规则，但是我真的获得了满足吗？并没有。也许是因为对方的一个“弱者”形象？也很难说，对方的情况基本都出自我的想象，我完全不了解对方。\n问了下爱人，也同样难过。总结了一下，大概有两点原因。\n1. 对个人认知的一次冲击\n我总觉得，世界应该是理性的，大家都遵守规则，那么世界一定会变的更加美好。然而，即使是对方的责任，但是事故本身依然对对方造成了伤害。要面对保费的增加，要去维修车辆，等等。\n对，即使是对方的责任，但是当我有能力避免事故的发生时，我还是觉得对对方的“伤害”，有我的一部分责任。\n然后这也让我意识到第二点原因：\n2. 善良的代价远比想象的大\n我一直告诉自己，要做一个善良的人。然而，善良的代价远比想象的大。\n我想起了 B 站某 UP 主，经常分享开车时遇到的事故，基本都是不让道造成的。很多时候可能让一下就没什么事了，但是他可能更多的选择一脚油门上去，任事故自然发展。\n我承认看到他的视频时，有时候还是很解气，毕竟开车多了，也经常遇到让人血压上升的情况。但是我也告诉自己，不要像他那样。虽然在某种程度上站在了法律的制高点上，但是在道德的高山上，他与别车的人都在山脚呢。\n想起罗翔老师的一句话，\u0026ldquo;法律是道德的最低标准\u0026rdquo;。法律只能规定一个人的下限，但是人的上限，却由另一套标准制定。\n回到关于善良的讨论。一个人想要善良，并不是嘴上说说就可以了。他要能够理解他人，尊重他人。必要的时候，可能还要让渡一些自己的利益，甚至还要自己消化掉一些负面情绪。（尤其是我觉得我开车的时候，负面情绪还是挺多的）。\n这让我思考自己，日常生活是否戾气过重了？如果我希望这个世界所有人都能与人为善，我真的有做到吗？\n今日的答案由过去谱写，明日的答案由今日书写。\n复杂的情绪催生出了这篇文章，相信这篇文章会成为我自己的一个\u0026quot;存档点\u0026quot;。也许未来我还会面对类似的抉择，开车也好，生活也罢。回想起今日的情绪，今日的思考，也许下一次，我就可以做出更好的选择。\n","date":"2025-05-30T20:44:50+08:00","permalink":"https://loveorange.github.io/posts/thoughts/first-accident/","title":"第一次交通事故有感"},{"content":"1. 简介 这次香港之行，除了 City Walk 与 Disney Land 之外，很重要的事情，是与世界 500 强企业（中银香港）的员工，聊了聊投资（出示投资记录），聊了聊创业（要不要在香港开公司），当然这一切的一切，都是为了开一个中银香港的账户（就是开户的问题啦）。\n为什么要开中银香港的账户？\n申请中银香港账户的最终要目的，就是最小化资金出海的损耗。在有中国银行账户的前提下，向中银香港账户转账可以做到免手续费，而且速度相对也比较快。\n同汇丰 One 账户一样，中银香港的账户也无管理费与最低存款要求，持有成本极低。\n2. 开户方式 中银香港只推荐线上预约开户。微信搜索「中银香港微服务」服务号，选择「银行服务」→「我要预约」，选择合适的时间与分行即可。\n某红书上有人尝试 Walk in 开户成功。但是我个人的经历，下午两点左右，在中环某分行，已经取不到开户的号了。\n也可以尝试在 APP 中申请，但是上传证件过程中，备受相机对焦问题的折磨，并且尝试 N 久之后，还是得到了「开户失败」的结果，所以也不推荐。\n3. 开户流程 3.1️. 预约开户 最重要的一步。微信搜索「中银香港微服务」服务号，选择「银行服务」→「我要预约」。\n每日零点放出七个工作日后的号，放号后预约比较容易，在白天基本无号。\n（也许是跨年预约的原因，我在预约的时候，没有严格提前七个工作日放出我想要的号，导致我多熬了一宿\u0026hellip;\u0026hellip;）\n3.2️. 抵达分行 按时抵达分行，与银行人员确认预约信息后，在预约柜台开始开户。\n我们此行预约了两个号，一个迟到了 5min，另一个早到了 25min，但是都没有排队。\n这里还得吐槽一句，从东涌到屯门，那个公交换乘的路线是认真的吗，这真的是常规路线吗？\n3.3️. 填写信息 开户期间，银行人员会要求在 App 上填写个人信息，根据个人情况填写。\n如果没有提前下载好 App，连接现场的 Wi-Fi 也可以下载，还会被推荐下载一个 BoC Pay 的 App，也许香港的银行朋友们也有指标要求吧\u0026hellip;\u0026hellip;\n3.4️. 开户询问 银行人员会询问个人情况，比如开户目的、个人工作与收入情况等，如实回答即可。\n比如我正在创（shi）业中，主要收入来源都是被动收入（0 - 5000 元挡位），也开户成功了。\n（或许我该在我的每篇 blog 下面挂个收款码增加收入了\u0026hellip;\u0026hellip;）\n3.5️. 获取银行卡 如果问及「是否要当场下卡」，果断选「是」。邮寄到内地有丢失风险。\n至少半个月了，我的汇丰的卡片还没到\u0026hellip;\u0026hellip;\n3.6️. 激活与入金 拿到卡片后，在 ATM 上存入一笔港币，完成激活与入金。如果卡片不识别，尝试稍等片刻重新插入。\n4. 注意事项 提前预约是最终要的，至少我其他的途径都没有开户成功，导致我去了两次香港了 有说中银香港态度较差。我预约的是建荣街分行，Google Maps 上只有 1.8 分，但是工作人员的态度超好，这里要给个好评 5. 总结 同汇丰一样，强烈建议线下开户，只要预约成功，现场开户十分顺利，全程 30 min 左右。\n祝大家开户顺利啦~\n6. 额外多说一句 作为一个伪·贝聿铭粉丝，提到香港就不得不提到的建筑就是中银大厦。建筑本身体现出了贝聿铭一贯的风格，背后的「风水大战」也十分有趣，感兴趣的小伙伴可以搜搜看。在香港这个风水宝地，「风水」确实是商战的重要一环了，不知道香港的建筑学专业是否有风水的选修课程。\n","date":"2025-03-05T20:06:01+08:00","image":"https://loveorange.github.io/posts/finance/boc-account-opening/victoria_harbour_hu_74c33b95e73097f2.jpg","permalink":"https://loveorange.github.io/posts/finance/boc-account-opening/","title":"港卡开户 2 - 中银香港"},{"content":"1. 简介 自从新加坡华侨银行限制开户后，港卡成为了海外开户的首选。而港卡之中，最受大家推崇的就是汇丰银行、中银香港和众安银行。这三家各有优势和用途，恰好最近完成了三家银行的开户，因此分别记录一下开户的过程和注意事项。\n本篇先更新汇丰银行。\n为什么要开汇丰银行的账户？\n汇丰银行在很多国家都有分行，不同地区同名账户之间互转免费。既然资金已经出海了，说不定未来会去到更多的国家和地区，先开一个汇丰香港的账户以备不时之需。\n而且汇丰银行的汇丰 One 账户，无管理费与最低存款要求，持有成本极低。\n2. 开户方式 汇丰银行虽然支持线上与线下两种开户途径，但是依然强烈推荐在线下开户。\n2.1. 线下 walk in 开户（推荐） 直接选择最近的分行，现场取号，通常等待 30min 到 1h 不等。\n🔔 注意事项\n汇丰分行的叫号声音很小，随时关注排号进度，避免过号 如果问及开户目的，回答投资理财 ✅ 优势\n可以直接拿卡 可以面对面的咨询一些使用问题 HSBC HK App 问题较多，线下开户会省心很多 2.2. HSBC HK App 申请，香港激活 需要在大陆完成的操作\n下载 HSBC HK App 后，按照提示填写资料。通常申请汇丰 One 账户即可 如果资料没什么问题，可以直接申请通过。如果提示“抱歉，我们无法立即为您开立账户”，一般等待五个工作日也会收到审批通过的信息 审批通过后，会收到一条包含验证编码的短信，需要在 90 天内使用该验证编码在香港完成激活 需要在香港完成的操作\n在 HSBC HK App 中，使用收到的参考编码与出入境记录，完成激活操作 激活成功后，会显示 HSBC HK 的账户号码，需要牢记，存款与转账时需要使用此账户号码 同样，激活成功后，会提示注册手机银行，直接点击注册，否则有概率 App 报错 找到最近的汇丰银行 ATM 入金。即使没有收到银行卡，使用激活后获得的账户号码，也可以在汇丰银行的 ATM 上存款 最后，等待卡片寄到通信地址 🔔 注意事项\n某些口岸的出入境记录，HSBC HK App 上可能无法识别，导致激活失败。我在 2024 年 11 月遇到了港珠澳口岸无法识别的问题，后从香港国际机场入境激活成功 激活成功后，如果没有直接点击注册手机银行，可能会导致点击时 App 报错，并且再也无法找到注册手机银行的入口。需要找到分行的工作人员帮助处理 线上申请时，最长需要五个工作日，需要合理安排行程 ✅ 优势\n大部分的申请操作都在大陆完成，如情况顺利，入境香港即可完成激活 ❌ 劣势\nHSBC HK App 操作时可能会遇到问题，部分情况仍需去分行处理 依然需要找到 HSBC 的 ATM 入金 3. 总结 强烈建议线下开户，等待的时间不会太长。开户过程中如遇到的问题，可以现场与银行人员沟通并解决，最重要的是可以当场下卡。\n线上申请如情况顺利，入境香港即可激活成功。但是遇到报错的话，还是需要到分行去解决。\n","date":"2025-02-19T20:06:01+08:00","image":"https://loveorange.github.io/posts/finance/hsbc-account-opening/central_market_hu_2fc0ace05f96537f.jpg","permalink":"https://loveorange.github.io/posts/finance/hsbc-account-opening/","title":"港卡开户 1 - 汇丰银行"},{"content":"0. 2024-12-04 更新 据不可靠消息（小红书、X），OCBC 目前不再支持大陆用户申请，因为我已经有账户了，所以没有尝试。\n另外今天发现我的账户被限制入金了，理由是「没有使用同名账户入金」，确实我的入金都是通过券商账户走的。客服说我需要去新加坡线下申请解封，可能需要提供一些证明材料，证明我在新加坡工作或生活。只能期待未来有时间去一趟新加坡了\u0026hellip;\u0026hellip;\n1. 引子 在经历了 A 股常常韭韭的体验后，我内心渐渐萌生了去买卖美股的想法。另外前公司发的股票（港股）一直在账户中起起落落落落，不能提取出来的钱只是数字。最终，申请一张海外银行卡的需求提上了日程。\n2. 卡片选择 对于大陆用户而言，内地汇款也好，海外投资也好，最理想的卡片一定是港卡。但是港卡开户有以下两个门槛（二选一）：\n内地开户：有一定的本金要求，50w 起步，不同银行略有区别 香港开户：不再有本金要求，但是需要人在香港 作为穷宅，一没有钱，二不想出门，只能寻找其他要求更低的银行。最终找到了「新加坡华侨银行（OCBC）」。\nOCBC 的开户条件几乎只有一个，就是护照。\n3. 开户 开户过程十分简单，在应用商店下载 OCBC 的 APP，按照要求填写资料、申请即可。等待几日的审核后，就会收到审核通过的通知。\n默认会创建 Statement Savings Account（SSA） 和 Global Savings Account（GSA） 两个账户，SSA 是 SGD 账户，而 GSA 可以储蓄更多的币种，比如 USD。\n除了这两个账户外，还可以在 APP 中申请一个 360 Account 账户，申请通过后会寄送一张实体的 Visa 卡，可以满足更多的支付场景。\n同时 OCBC 还支持名为「PayNow」的类似支付宝的二维码支付方式。可以在 360 Account 的页面上，点击右上角的设置按钮「⚙️」-\u0026gt;「Manage PayNow」绑定 PayNow 账户，这样其他的 PayNow 用户可以通过搜索我们的手机号，直接向我们的账户转账。\n4. IBKR 为了买卖港股、美股，还需要申请券商账号。可选择的券商有很多，我选择的是「盈透证券（IBKR）」。IBKR 据说更符合传统的股票交易思维，有很多专业用户，对我而言使用的起来要比「雪球」复杂。「长桥证券」也是一个比较好的选择，更符合国内用的使用思路，但是需要已经有其他海外的券商账户才能申请下来。\n申请同样是按照需求填写资料，静待审核。\n5. Wise 有了银行账户与券商账户，此时已经可以进行港股、美股的买卖了。为了出入金方便，我额外申请了一个 Wise 账户。\nWise 是一个汇款工具，相比国际银行之间的转账，Wise 提供了更简单的转账方式，相当于不同国际银行账户之间的中介。对于 OCBC，支持通过 PayNow 的方式入金出金，极大地简化了银行与券商间的转账流程，强烈建议申请一个，申请同样十分简单。\n6. OCBC 到 IBKR 入金出金 有了 Wise 后，我从 OCBC 向 IBKR 的入金路径就变成了：\nOCBC -\u0026gt; Wise -\u0026gt; IBKR\nOCBC -\u0026gt; Wise：使用 PayNow 扫码付款，可以在几秒内到账 Wise -\u0026gt; IBKR：在 IBKR 中可以选择使用 Wise 入金。关联 Wise 账户后，即可将 Wise 的余额快速转入 IBKR 出金的流程理论上类似，因为我还没有在 IBKR 上大富大贵，还没有尝试出金。\n需要注意的是，第一次出金入金可能会有额外的验证，验证通过后，后续的出金入金就十分顺畅了。\n7. 向海外转账 介绍了从 OCBC 到 IBKR 的入金出金后，还有一个重要的流程，就是国内的钱如何转到OCBC。\n我在 OCBC 的第一笔存款是卖掉已有的港股的钱转存的，因此我没有从国内的银行向 OCBC 转过账。这里只贴一个理论上的路线，大家可以根据自己的银行自行搜索相关的教程。\n购汇：在岸人民币没有办法简单的向海外流通，因此我们要提前把人民币换成新加坡元，再转入 OCBC 中。银行的 APP 中一般都提供了购汇的选项，大家可自行查找。 转账：有了新加坡元后，就可以向海外的银行转账了。转账需要银行的名称、地址、SWIFT Code 等信息，可以在 Wise 上查询到。这里也列一下 OCBC 的相关信息。 Bank name: OVERSEA-CHINESE BANKING CORPORATION LIMITED SWIFT code: OCBCSGSGXXX Bank address: 63 CHULIA STREET, FLOOR 10, OCBC CENTRE City: Singapore Country: Singapore 8. 总结 如果有配置海外资产的需求的话，申请一个 OCBC 的账户可能是最简单的起步了。在有护照的前提下，几乎可以做到足不出户即可申请。搭配 IBKR、Wise，可以轻松实现港股、美股的买卖。虽然向 OCBC 账户转账稍有麻烦，并且可能会产生额外的费用。但是考虑 OCBC 的申请难度，作为起步来说，还是个较为便捷的选择。当然如果有更大额或者更频繁的转账需求，申请一张港卡还是更好的选择。\n最后，祝大家的财富能够稳健的增长，早日实现财务自由～\n","date":"2024-12-02T13:57:45+08:00","permalink":"https://loveorange.github.io/posts/finance/ocbc/","title":"OCBC - 年轻人的第一张海外银行卡"},{"content":"1. 引言 讲一个最近遇到的问题。在 VSCode 和 Cursor 输入中文时，editor 的文字一直在颤抖。日常写注释时影响不大，但是在写 Blog 的时候，大量的中文输入，而文字一直颤抖，体感很差。\n2. 解决 搜了一些资料以及尝试后，发现问题出现在 Vim 插件上，卸载或禁用 Vim 插件后，问题不再复现。\n参考：VSCode 输入中文时 editor 文字颤抖\n但是对于 Vim 星人来说，不使用 Vim 几乎不会打字了，那么介绍两种另外的解决办法。\n2.1. 方案一：修改 VSCode 配置 上述 Issue 中给出了解决方案，在 VSCode 配置中添加以下配置：\n1 \u0026#34;editor.experimentalEditContextEnabled\u0026#34;: true 重启后即可生效。\n但是 Cursor 中没有这个配置，因此我们继续探索另外的解决办法。\n2.2. 方案二：使用 NeoVim 插件 对于 Vim，我更多的需求是使用 Vim 的键位，那么找一个能够提供 Vim 键位的插件即可，这里我选择的是 NeoVim。\n除了插件外，还需要安装 NeoVim 客户端，可以使用 Homebrew 安装：\n1 brew install neovim 同样重启后生效。\n3. 其他的问题：无法连续移动光标 安装好 NeoVim 后，发现了另一个问题，按住 hjkl 时，无法持续移动光标，效率很差。\n这里涉及到一个 MacOS 的问题。MacOS 中有一个默认的按键重复限制，对于特定按键来说，按住时会显示字符选择框。可以在终端中针对特定的应用禁用。\nVSCode 禁用方法：\n1 defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false 这里的 com.microsoft.VSCode 是 VSCode 的 Bundle ID。\nCursor 的 Bundle ID 不像 VSCode 这么统一，可以使用以下命令查询：\n1 osascript -e \u0026#39;id of app \u0026#34;Cursor\u0026#34;\u0026#39; 我显示的 Bundle ID 是 com.todesktop.230313mzl4w4u92，因此禁用命令为：\n1 defaults write com.todesktop.230313mzl4w4u92 ApplePressAndHoldEnabled -bool false 需要强制退出 VSCode 和 Cursor 后生效，⌘ + Q 一下吧。\n至此，VSCode 与 Cursor 的输入问题解决，继续开心的码代码吧～\n","date":"2024-11-16T07:34:33+08:00","permalink":"https://loveorange.github.io/posts/vscode-input-bug-fix/","title":"修复 VSCode、Cursor 输入中文时字符颤抖问题"},{"content":"1. 引言 人类的本质就是颜狗\n美丽的事物可以提升生产力。\n最近入手了新的 Mac Mini M4，新机新气象，初始化工作就从终端美化开始吧。\n2. 总览 本次美化先从系统自带的 Terminal 入手，其他的终端工具如 iTerm 等优化方式差异不大。\n主要使用：\nzsh 默认 shell oh-my-zsh zsh 的增强 Powerlevel10k 主题 ayu 配色 Cascadia Code NF 字体 最终效果如下：\n3. 配置 3.1 安装 zsh 与 oh-my-zsh 此处假设已经安装了 homebrew。\n安装 zsh 的命令十分简单，考虑还要安装 oh-my-zsh，所以一起安装 Git。\n1 brew install zsh git 接下来从 oh-my-zsh 的官网获取安装命令。\n1 sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 3.2 安装字体 为了在 Terminal 提供丰富多彩的现实，建议安装 Nerd Font，否则特殊符号无法正常显示。可以在 Nerd Fonts 中选择喜欢的字体。\n作为微软信徒，我选择了微软提供的 Cascadia Code，刚好官方提供了 Nerd Font 版本。\n3.3 安装 Powerlevel10k 默认的 oh-my-zsh 主题比较简陋，推荐使用 Powerlevel10k，提供了基本的自定义功能，可以满足大部分需求。\n安装命令如下：\n1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 修改 ~/.zshrc 文件，将主题设置为 Powerlevel10k。\n1 ZSH_THEME=\u0026#34;powerlevel10k/powerlevel10k\u0026#34; 3.4 安装配色 在 iterm2-colors-solarized 中提供了丰富的配色方案。可以选择喜欢的配色单独下载，选择困难症也可以 clone 整个仓库慢慢纠结。\n1 git clone https://github.com/mbadolato/iTerm2-Color-Schemes.git terminal 目录下提供了 Terminal 的配色方案。\nschemes 目录下提供了 iTerm 的配色方案。\n我选择的是 ayu 配色，调整了透明度为 80%，模糊度为 20%。\n4. 总结 至此配置结束，整个过程不算复杂，基本上十分钟左右可以配置结束。\n为了尽快能够让新电脑提供生产力，本次美化还是选择了最熟悉的方案，尽量保证原有的开发习惯。\n近年也涌现出一批优秀有趣的终端工具，如 WezTerm，Starship，Kitty，等有时间的话再慢慢尝试了。\n","date":"2024-11-15T10:15:41+08:00","image":"https://loveorange.github.io/posts/beautiful-terminal/image_hu_ff63195e21a04cb.png","permalink":"https://loveorange.github.io/posts/beautiful-terminal/","title":"Zsh 极简终端美化"},{"content":"1. 题目介绍 原题链接：10. 正则表达式匹配，难度：Hard。\n给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。\n'.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n虽然是早期的 Hard，但是这道题的难度还是很高的，尤其以这道题的代码量来说。\n2. 问题分析 首先需要分析问题的类型。如果说不存在 '.' 和 '*'，字符的话，那么只要 equals() 即可了。当然这道题不会这么善良。\n首先引入 '.' 的概念，如果除了 '.' 之外的字符与位置都一致，那么也可以简单的判断是否能够匹配。\n最后引入 '*' 的概念，它会将前一个的字符重复任意次数，也就是说，需要考虑前面的字符不会出现，以及出现多次，下述几种情况前面的字符串为 s，后面的为 p：\nacd 和 ab*cd：b 出现 0 次，可以匹配 abcd 和 ab*cd：b 出现 1 次，可以匹配 abcd 和 ab*bcd：b* 实际没有使用，匹配的是 p.charAt(3) 的字符 b 需要记录类似例子 3 中 b* 能够匹配的 s 的位置，因此考虑这是个 dp 问题，需要记录截止到 p 的第 j 个字符为止，能够匹配 s 的第 i 个字符。\n接下来考虑状态转移方程。对于没有 '*' 的世界来说，仅需要判断两种情况：\ns.charAt(i) == p.charAt(j) p.chatAt(j) == '.' 显然状态转移方程为 dp[i][j] = dp[i - 1][j - 1] \u0026amp; {上述两种情况}。 复杂性同样在引入了 '*' 的世界里。还需要考虑以下三种情况：\n如果不使用 '*' 以及它前面的字符，那么存在 dp[i][j] = dp[i - 1][j - 2] 如果使用 '*' 以及它前面的字符，则有： 当 s.charAt(i) == p.charAt(j - 1) 或者 p.charAt(j - 1) == '.' 时，即 s 的第 i 个字符与 p 的 j - 1（'*' 前的字符）一致时，dp[i][j] = dp[i - 1][j]，与 dp[i - 1][j] 比较的原因是，可以想象成 dp[i - 1][j] 中的 '*' 与其前置字符没有被使用 上述判断不成立，返回 false 为此，我们大概可以总结出了状态转移方程。\n还需要考虑的特殊情况是，当 s 或者 p 为空串的场景，为了简化这种场景，我们初始化 dp 数组时，使用 boolean[][] dp = new boolean[s.length() + 1][p.length() + 1] 来初始化。考虑到 p 的第一个字符不会是 '*'，那么只要 s 为空串时，除了 p 也为空串的场景，都无法进行匹配。\n3. 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); // 因为使用 m + 1 与 n + 1 进行初始化， // 后续使用 .charAt 时，需要将 i j 减 1 boolean[][] dp = new boolean[m + 1][n + 1]; // 空串可以互相匹配 dp[0][0] = true; for (int i = 0; i \u0026lt; m + 1; i++) { for (int j = 1; j \u0026lt; n + 1; j++) { // 先考虑没有 \u0026#39;*\u0026#39; 的世界 if (p.charAt(j - 1) != \u0026#39;*\u0026#39;) { dp[i][j] = isMatch(s, i, p, j) ? dp[i - 1][j - 1] : false; } else { // 引入 \u0026#39;*\u0026#39; 后，先考虑不使用 \u0026#39;*\u0026#39; 与前置字符 dp[i][j] = dp[i][j - 2]; // 如果 s.charAt(i - 1) == p.charAt(i - 2) // 即当前遍历的 s 的字符，与 p 中 * 前的字符相同 if (isMatch(s, i, p, j - 1)) { // 那么 s 直到 i - 1 与 p 直到 j - 1 能否匹配， // 取决于 dp[i][j - 2] 与 dp[i - 1][j] 的结果 dp[i][j] = dp[i][j] || dp[i - 1][j]; } } } } return dp[m][n]; } private boolean isMatch(String s, int si, String p, int pi) { if (si == 0) { return false; } if (p.charAt(pi - 1) == \u0026#39;.\u0026#39;) { return true; } return s.charAt(si - 1) == p.charAt(pi - 1); } } 4. 一些总结 这道题的难点我觉得有两个，第一个是想到动态规划的解法，我最开始想用回溯来做，发现需要考虑的场景很多，然后无情的看了答案；第二个是找出状态转移方程，需要考虑引入了 * 之后，是否使用 * 与前置字符，从而得出 dp[i][j] = dp[i][j - 2] || dp[i - 1][j] 这一步。想到这两点后，额外需要注意的就是考虑空串的情况了。\n总觉得几个月后再看这道题，还是会忘\u0026hellip;\u0026hellip;\n","date":"2024-03-18T22:12:04+08:00","permalink":"https://loveorange.github.io/posts/leetcode/regular-expression-matching/","title":"LeetCode 10. 正则表达式匹配"},{"content":"1. 题目介绍 原题链接：403. 青蛙过河，难度：Hard。\n一只青蛙想要过河。假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。青蛙可以跳上石子，但是不可以跳入水中。\n给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位（即只能从单元格 1 跳至单元格 2 ）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n对我个人有很深意义的一道题，很久之前面试微软时遇到的题，结果时隔多年我忘记怎么做了\u0026hellip;\u0026hellip;\n2. 问题分析 首先想到的是能不能通过穷举列出所有的可能性，然后发现穷举起来也挺麻烦的，难度可能不亚于想一个更靠谱的算法了，那么继续试试其他的路子。\n能否跳到最终的石头，取决于能否跳到上一个石头的步数 k，能否恰好在 [k - 1, k + 1] 之间；那能否跳到上一个石头，取决于\u0026hellip;\u0026hellip;于是我们闻到了一丝动态规划的味道。\n因为这是一只遗忘了游泳的青蛙，只能挑到石头上，并且每次跳只能是 k 个单位，那我们从两个方向考虑：\n青蛙起跳时，如果上一次跳跃了 k 个位置来到了当前位置 i ，那么下一次跳跃只能跳到 i + k - 1、i + k、i + k + 1 这三个位置，如果目的位置有石头的话，我们就可以晚一点想象这只可怜的青蛙溺水的样子。简单来说就是从当前位置，可以跳到哪里。 青蛙跳到了某个石头 i 时，如果知道了上次起跳的石头位置 j，那么显然上次跳跃的距离为 k = i - j。如果我们知道了所有能跳到当前石头 i 的距离 k，那么我们可以根据上一步酸楚青蛙能够跳到的下一个石头的位置。也就是从哪里能够跳到当前位置 结合这两点，我们发现需要维护一个重要的信息：从位置 i 能否跳跃到 j。这也是这道题的关键，能否想到使用一个二维数组，通过 dp[i][j] 的方式来表示能否从位置 i 跳到 j。\n有了 dp[i][j] 之后，只需要遍历石头的位置，每次跳到位置 j 时，找到所有能跳到 j 的位置 i，记录下跳跃的距离，再分别记录能跳跃到的目标位置 j + k - 1、j + k、j + k + 1 是否有石头即可。\n如果发现恰好能挑到最后一块石头，即可结束遍历。\n有一些可以减少内存占用的优化。根据题目给出的数据范围，石块的位置可能远大于石块的数量， 可以使 dp[i][j] 中的 i 和 j 分别表示石块在 stones 的索引。另外只需要记录能否从 i 跳到 j 即可，dp[i][j] 可以使用 boolean 来表示。\n3. 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public boolean canCross(int[] stones) { int n = stones.length; if (stones[1] != 1) { return false; } Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { map.put(stones[i], i); } boolean[][] dp = new boolean[n][n]; dp[0][1] = true; for (int j = 0; j \u0026lt; n; j++) { for (int i = 0; i \u0026lt;= j; i++) { if (dp[i][j]) { int k = stones[j] - stones[i]; int next = stones[j] + k - 1; if (map.containsKey(next)) { dp[j][map.get(next)] = true; } next++; if (map.containsKey(next)) { dp[j][map.get(next)] = true; } next++; if (map.containsKey(next)) { dp[j][map.get(next)] = true; } } } } // 可以在上面的 for 循环中判断是否到达终点 // 但是我不想破坏上面整齐的结构 for (int i = 0; i \u0026lt; n; i++) { if (dp[i][n - 1]) { return true; } } return false; } } 4. 一点吐槽 这是青蛙唉，会游泳的，不管它跳不跳石头，它都能过河的撒。我觉得这道题的解就应该是：\n1 2 3 4 5 6 class Solution { public boolean canCross(int[] stones) { // 如果青蛙过不去，那就只能说是它不想过去 return true; } } ","date":"2024-03-14T20:55:41+08:00","permalink":"https://loveorange.github.io/posts/leetcode/frog-jump/","title":"LeetCode 403. 青蛙过河"},{"content":"1. 题目介绍 原题链接：297. 二叉树的序列化与反序列化，难度：Hard。\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n作为计算机领域常用的技术，序列化与反序列化的方式有很多，如何更快的序列化，如何减少序列化后的体积，一直是很多人追求的目标。\n本题只列举了一个场景，即二叉树的序列化与反序列化，实际中遇到更多的场景可能是将一个自定义结构的对象进行序列化，常见的如 RESTful 接口等，通常被序列化为 JSON 或者 XML 的格式。\n这道题让我想起了之前公司的需求，对一整棵 Maven 依赖树进行序列化，然后存放在了 S3 上做 snapshot。不过实际环境里用到的方式要更粗暴一些，直接用的 ProtoBuf 将整棵树的对象序列化了\u0026hellip;\u0026hellip;\n2. 问题分析 简化一下，问题可以变为将一棵二叉树使用字符串的形式表示，第一反应应该就是前、中、后序表达式了。\n联想到了构造二叉树的三兄弟：\n105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 889. 根据前序和后序遍历构造二叉树 对于这三道题目来说，知道任何两种遍历的方式后，可以反序列化成完整的二叉树。\n那么对于这道题，是否也需要序列化成两种不同的序列，才能够反序列化成二叉树吗？其实不然。对于构造二叉树三兄弟来说，很重要的一点是找到左右子树的节点数量，进而找到叶子节点。但是对于本题，序列化的方式我们可以自己控制，我们可以自行在节点后添加 null 节点，来标识当前结点没有左子节点或右子节点。\n因此我们可以尝试使用先序遍历的方式，对于序列化的过程：\n每遍历一个节点，则在序列化的字符串末尾添加 {node.val}, 如果节点为空，则添加 N,，具体的值可以根据喜好自行控制。等短的字符会节约空间 对于反序列化的过程：\n获取所有的节点值，通过截取分隔符 , 获得 如果节点值为 N，表示当前结点为空 按照先序遍历的顺序，先构造跟结点，再依次构造左子节点和右子节点 一点优化，使用 List\u0026lt;Integer\u0026gt; 保存所有的节点值，每遍历一个节点就删除一个节点，可以避免记录当前遍历的顺序。而且在使用先序遍历的情况下，List 中的第一个值就是当前节点的值 3. 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { return doSerialize(root, \u0026#34;\u0026#34;); } private String doSerialize(TreeNode root, String str) { if (root == null) { str += \u0026#34;N,\u0026#34;; return str; } str += root.val + \u0026#34;,\u0026#34;; str = doSerialize(root.left, str); str = doSerialize(root.right, str); return str; } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] strs = data.split(\u0026#34;,\u0026#34;); return doDeserialize(new LinkedList\u0026lt;\u0026gt;(Arrays.asList(strs))); } private TreeNode doDeserialize(List\u0026lt;String\u0026gt; nodes) { if (\u0026#34;N\u0026#34;.equals(nodes.get(0))) { nodes.remove(0); return null; } TreeNode root = new TreeNode(Integer.parseInt(nodes.get(0))); nodes.remove(0); root.left = doDeserialize(nodes); root.right = doDeserialize(nodes); return root; } } // Your Codec object will be instantiated and called as such: // Codec ser = new Codec(); // Codec deser = new Codec(); // TreeNode ans = deser.deserialize(ser.serialize(root)); 4. 相关题目 105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 889. 根据前序和后序遍历构造二叉树 5. 一点额外的吐槽 这种解法的优势在于易于理解，但是运行的效率并不高，LeetCode 执行用时 61ms。看了一眼最快的解法，只能说很是离谱了。\n好孩子不要学：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Codec { static TreeNode t; // Encodes a tree to a single string. public String serialize(TreeNode root) { t = root; return \u0026#34;\u0026#34;; } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { return t; } } ","date":"2024-03-13T21:02:09+08:00","permalink":"https://loveorange.github.io/posts/leetcode/serialize-and-deserialize-binary-tree/","title":"LeetCode 297. 二叉树的序列化与反序列化"},{"content":"1. 题目介绍 原题链接：239. 滑动窗口最大值，难度：Hard。\n给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n2. 问题分析 因为滑动窗口的长度为 k，所以最终返回的结果是一个长度为 nums.length - k + 1 的数组。如果这是大学期末考试题的话，写到这里至少应该能得两分。\n接下来想办法获取每 k 个长度内的最大值。假设我们已经维护了 [i, i + k) 个数字的数组 arr，并且按照从大到小的顺序排序了。那么当索引移动到 i + 1 时，我们需要做的就是将数组 arr 中，按照从大到小的顺序，移除不在索引 [i + 1， i + k + 1) 的数字，那么此时数组的头部元素即是当前段的最大值。\n考虑到数组中的数字允许重复，如果在 [i, i + k) 段中，有两个最大值，那么我们优先考虑使用后面的索引，因为它更有可能在下一段中也是最大值。因此在数组 arr 中，除了要维护 [i, i + k) 的值外，还需要将它们对应的索引也维护起来，并且按照值大小、索引位置进行排序。\n为了简化排序流程，可以考虑使用「优先队列」的数据结构。初始化如下的优先队列，队列的每一个元素是一个数组，值为 { nums[i], i }。\n1 2 PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((ar1, ar2) -\u0026gt; ar1[0] == ar2[0] ? ar2[1] - ar1[1] : ar2[0] - ar1[0]); 3. 代码实现 最终代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; PriorityQueue\u0026lt;int[]\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((ar1, ar2) -\u0026gt; ar1[0] == ar2[0] ? ar2[1] - ar1[1] : ar2[0] - ar1[0]); for (int i = 0; i \u0026lt; k; i++) { pq.offer(new int[]{ nums[i], i }); } int[] res = new int[n - k + 1]; res[0] = pq.peek()[0]; for (int i = k; i \u0026lt; n; i++) { pq.offer(new int[]{ nums[i], i }); while (pq.peek()[1] \u0026lt;= i - k) { pq.poll(); } res[i - k + 1] = pq.peek()[0]; } return res; } } 此代码的速度并不快，LeetCode 执行时将约为 86 ms。推测为优先队列本身的排序比较耗时。可以考虑使用单调栈的方式对选取 [i, i + k) 中最大值的部分进行优化。\n","date":"2024-03-13T09:46:47+08:00","permalink":"https://loveorange.github.io/posts/leetcode/sliding-window-maximum/","title":"LeetCode 239. 滑动窗口最大值"},{"content":"1. 题目介绍 原题链接：76. 最小覆盖子串\n题目的描述很简单：\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n最小覆盖子串是很经典的面试题了，也是我 17 年面试微软的原题。\n2. 问题分析 这是一个典型的滑动窗口问题，让我们来一步一步分析这道题。\n题目中要求找到字符串 s 中涵盖字符串 t 的所有字符，那么首先需要统计字符串 t 中有多少字符，可以使用一个 Map\u0026lt;Character, Integer\u0026gt; map 来存储 t 中的字符以及出现的次数。\n接下来就是滑动窗口的思路，设定滑动窗口的两端 left 和 right，使用 Map\u0026lt;Character, Integer\u0026gt; window 记录滑动窗口中的字符数量。\n首先不断地向前移动右边界 right，直到 left 和 right 中的字符完全包含了 map 中的字符。\n确定好右边界后，收缩左边界，同样地向前移动 left，直到 left 与 right 中的字符不再完全包含 map 中的字符，则左边界收缩结束。\n可以使用 start 和 end 记录能够完全覆盖 map 中的字符时，left 与 right 的值。\n判断 left 与 right 中的字符是否完全包含 map 中的值，可以直接比较两个 Map\u0026lt;Character, Integer\u0026gt;，也可以使用额外的变量记录符合条件的字符数量，优化判断的时间。\n3. 代码实现 最终代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public String minWindow(String s, String t) { int n = s.length(); Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (char c : t.toCharArray()) { map.put(c, map.getOrDefault(c, 0) + 1); } int left = 0, right = 0; int start = 0, end = Integer.MAX_VALUE; int valid = 0; Map\u0026lt;Character, Integer\u0026gt; window = new HashMap\u0026lt;\u0026gt;(); while (right \u0026lt; n) { char c = s.charAt(right); if (map.containsKey(c)) { window.put(c, window.getOrDefault(c, 0) + 1); if (window.get(c) \u0026lt;= map.get(c)) { valid++; } } // 因为在当前循环的末尾执行的 right++ // 因此这里的判断条件需要包含等号 while (left \u0026lt;= right \u0026amp;\u0026amp; valid == t.length()) { if (right - left \u0026lt; end - start) { start = left; end = right; } char d = s.charAt(left); if (map.containsKey(d)) { window.put(d, window.get(d) - 1); if (window.get(d) \u0026lt; map.get(d)) { valid--; } } left++; } right++; } return end == Integer.MAX_VALUE ? \u0026#34;\u0026#34; : s.substring(start, end + 1); } } 4. 相似题目 面试题 17.18. 最短超串 ","date":"2024-03-12T21:53:01+08:00","permalink":"https://loveorange.github.io/posts/leetcode/lc-76-minimum-window-substring/","title":"Leetcode 76. 最小覆盖子串"},{"content":"1. 引言 1.1. 需求 最近在开发一个基于 Spring Boot 框架的制品管理平台，使用了领域驱动设计的思想进行了业务模型的设计。\n开发过程中遇到了一个常见的需求：创建不同类型的制品（Artifact）。需求概括如下：\n不同的构建任务会生成不同类型的制品，如 Jar 包、Dockers 镜像等； 所有类型的制品具备一些公共的属性，如名称、描述、创建时间等； 不同类型的制品存在一些独有的属性，如存储位置、是否关联图片等； 制品的独有属性用于创建后，触发下游的其他任务。 对于 CRUD Boys 来说，是一个十分常见的需求，最简单的实现方式就是使用贫血模型。\n1.2. 贫血模型 贫血模型由 Martin Fowler 在 2003 年提出，是一种将数据和行为分离的设计模式。\n在贫血模型中，Controller 层接受不同类型制品的创建请求（DTO），Service 层负责将请求映射为持久化对象（PO），DAO 层负责将持久化对象存储到数据库中。\n对于大多数 CRUD 请求来说，贫血模型可以说是一套“万能公式”，支撑起了无数的 Java 服务。但是，贫血模型也有着一些明显的缺点：\n模型不能反馈业务逻辑，开发人员无法深入地理解业务； 大部分的 CRUD 逻辑存在相似性，代码复用性较差； 一旦新增了业务逻辑，此处为制品类型，需要新增接口和表结构，维护成本较高。 现有流程增加业务逻辑时，需要修改所有的流程，重复工作量较大。 1.3. 基于可复用性的设计 **DRY 原则（Don\u0026rsquo;t Repeat Yourself）**是软件工程中的一条重要原则，它要求系统减少重复，提高代码的可复用性。\n为了做到这一点，首先需要的是对已有的需求进行更高层次的抽象，既要将相似的业务逻辑进行整合，也要让每种类型能够管理自己的特殊属性。其次，适当的引入设计模型也可以简化代码的复杂度，提高代码的可维护性。\n2. 需求分析 2.1. 需求建模 让我们回顾一下需求，找到其中的共性和差异性：\n共性 所有类型的制品都有名称、描述、创建时间等属性； 制品可以使用相同的逻辑进行处理、存储； 制品的独有属性都是用于触发下游任务。 差异性 不同类型的制品有着不同的特殊属性。 因此，我们首先对创建请求进行抽象，对于 Jar 包和 Docker 镜像类制品，可以创建如下 DTO 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public abstract class ArtifactDTO { protected String name; protected String description; protected Date createTime; public abstract ArtifactType getType(); } public enum ArtifactType { JAR, DOCKER; } public class JarArtifactDTO extends ArtifactDTO { private String groupId; private String artifactId; private String version; @Override public ArtifactType getType() { return ArtifactType.JAR; } } public class DockerArtifactDTO extends ArtifactDTO { private String tag; @Override public ArtifactType getType() { return ArtifactType.DOCKER; } } DTO 对象如下图所示：\n考虑使用 DDD 的设计思想，我们还需要对领域对象进行建模，首先是父类 Artifact：\n1 2 3 4 5 6 7 8 9 public abstract class Artifact { protected String name; protected String description; protected Date createTime; // 保存特殊属性，用于触发下游任务 protected Map\u0026lt;String, String\u0026gt; specialProperties; public abstract ArtifactType getType(); } 其次，针对每一个特殊的制品类型，创建一个子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class JarArtifact extends Artifact { private String groupId; private String artifactId; private String version; @Override public ArtifactType getType() { return ArtifactType.JAR; } } public class DockerArtifact extends Artifact { private String tag; @Override public ArtifactType getType() { return ArtifactType.DOCKER; } } 领域对象如下图所示：\n2.2. 需求简化 对 DTO 和 Entity 建模后，可以发现制品的创建过程可以被简化为：\n根据 DTO 的类型创建对应的 Entity； 填充 DTO 的共有属性； 处理不同类型 DTO 的独有属性。 2.3. 模式选择 在我们的项目中，使用 DTO 表示前端传递的数据，使用 Entity 表示领域模型。每个请求都会经过下述的流程：\nController 层接收 DTO； Service 层根据 DTO 的内容创建 Entity； 处理业务逻辑。 对于这种情况，我们可以使用工厂方法模式和抽象工厂模式来实现。工厂方法模式用于根据 DTO 的类型不同，实现不同种类 Entity 的初始化逻辑；抽象工厂用于根据 DTO 的类型不同，选择不同的工厂方法。\n如果对象的初始化较为复杂，还可以使用构建器模式来构建对象。\n3. 代码实现 3.1. 工厂方法 首先，我们需要定义一个工厂接口，用于创建不同类型的制品：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public interface ArtifactFactory\u0026lt;T extends ArtifactDTO\u0026gt; { /** * 获取工厂对应的制品类型，用于抽象工厂的选择 * * @return 制品类型 */ ArtifactType getArtifactType(); /** * 根据 DTO 类型创建对应的制品 * * @param dto 创建制品 DTO * @return 制品 */ Artifact createEmptyArtifact(); /** * 获取制品的特殊属性 * * @param dto 创建制品 DTO * @return 特殊属性 */ Map\u0026lt;String, String\u0026gt; getSpecialProperties(T dto); /** * 创建制品 * * @param dto 创建制品 DTO * @return 制品 */ default Artifact createSubArtifact(T dto) { Artifact artifact = createEmptyArtifact(dto); artifact.setName(dto.getName()); artifact.setDescription(dto.getDescription()); artifact.setCreateTime(dto.getCreateTime()); artifact.setSpecialProperties(getSpecialProperties(dto)); return artifact; } default Artifact createArtifact(ArtifactDTO dto) { if (dto.getType() != getArtifactType()) { throw new IllegalArgumentException(\u0026#34;Unsupported artifact type: \u0026#34; + dto.getType()); } return createSubArtifact((T) dto); } } 在工厂方法中，有以下几点需要注意：\n为了简化代码，我们提供了一个默认实现 createSubArtifact 方法，用于创建制品、填充共有属性和处理特殊属性； 我们希望 DTO 到 Entity 的代码可以复用，因此用泛型 T 表示 DTO 类型； 由于 Java 的泛型擦除机制，我们需要在 createArtifact 方法中进行类型转换，同时在此方法中进行了类型检查。 然后，我们需要为每种类型的制品创建一个具体的工厂类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Component public class JarArtifactFactory implements ArtifactFactory\u0026lt;JarArtifactDTO\u0026gt; { @Override public Artifact createEmptyArtifact() { return new JarArtifact(); } @Override public Map\u0026lt;String, String\u0026gt; getSpecialProperties(JarArtifactDTO dto) { Map\u0026lt;String, String\u0026gt; specialProperties = new HashMap\u0026lt;\u0026gt;(); specialProperties.put(\u0026#34;groupId\u0026#34;, dto.getGroupId()); specialProperties.put(\u0026#34;artifactId\u0026#34;, dto.getArtifactId()); specialProperties.put(\u0026#34;version\u0026#34;, dto.getVersion()); return specialProperties; } } @Component public class DockerArtifactFactory implements ArtifactFactory\u0026lt;DockerArtifact\u0026gt; { @Override public Artifact createEmptyArtifact() { return new DockerArtifact(); } @Override public Map\u0026lt;String, String\u0026gt; getSpecialProperties(DockerArtifact dto) { Map\u0026lt;String, String\u0026gt; specialProperties = new HashMap\u0026lt;\u0026gt;(); specialProperties.put(\u0026#34;tag\u0026#34;, dto.getTag()); return specialProperties; } } 将每一个工厂类标记为 @Component，可以让 Spring Boot 自动扫描并注册到容器中。\n3.2. 抽象工厂 工厂方法创建好后，我们还期望可以根据 DTO 的类型自动选择对应的工厂。\n考虑在 Spring 中可以使用 @Autowired 注解来自动注入所有的工厂 Bean，我们可以提供制品类型到工厂的映射：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Component public class ArtifactFactoryRegistry { private final Map\u0026lt;ArtifactType, ArtifactFactory\u0026gt; factoryMap; /** * 构造函数，使用 Spring 自动注入所有的工厂列表 * * @param factories 工厂列表 */ @Autowired public ArtifactFactoryRegistry(List\u0026lt;ArtifactFactory\u0026gt; factories) { factoryMap = factories.stream() .collect(Collectors.toMap(ArtifactFactory::getArtifactType, Function.identity())); } /** * 根据 DTO 类型创建对应的制品 * * @param dto 创建制品 DTO * @return 制品 */ public Artifact createArtifact(ArtifactDTO dto) { ArtifactFactory factory = factoryMap.get(dto.getType()); if (factory == null) { throw new IllegalArgumentException(\u0026#34;Unsupported artifact type: \u0026#34; + dto.getType()); } return factory.createArtifact(dto); } } 3.3. 使用 在 Service 层中，我们可以直接使用 ArtifactFactoryRegistry 来创建制品：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service public class ArtifactService { private final ArtifactFactoryRegistry factoryRegistry; @Autowired public ArtifactService(ArtifactFactoryRegistry factoryRegistry) { this.factoryRegistry = factoryRegistry; } public void createArtifact(ArtifactDTO dto) { Artifact artifact = factoryRegistry.createArtifact(dto); // ... 省略其他业务逻辑 } } 4. 优势 通过引入抽象工厂和工厂方法模式，我们可以获得以下优势：\n易扩展：新增一个制品类型，只需要新增一个工厂类，Service 层的代码完全不需要修改； 好维护：不同类型的制品使用不同的工厂，代码逻辑清晰，易于维护。 5. 后续优化 5.1. 接口可以合并 在示例代码中仅提供了 Service 的使用，在我们目前的视线中，Controller 层还是为一个类型的制品单独提供了创建的接口，后续计划使用 Jackson 的反序列化特性，将所有的制品类型统一为一个接口。\n6. 结论 DRY 原则是软件工程中的一条重要原则，它要求系统减少重复，提高代码的可复用性。\n通过对需求深度分析，提供更高阶别的抽象，可以帮助找到系统中的共性和差异，提升代码的复用性。\n通过引入设计模式，可以进一步简化代码的复杂度，提高代码的可维护性，有助于后续的扩展。\n将复杂的问题化繁为简，在一层层的抽丝剥茧后，找到最简洁的设计并予以实现，这正是软件开发的乐趣所在。\n7. 参考 Martin Fowler: AnemicDomainModel Abstract Factory Pattern Factory Method Pattern ","date":"2024-02-20T18:04:59+08:00","permalink":"https://loveorange.github.io/posts/springboot-factory-pattern/","title":"在 Spring Boot 中使用抽象工厂和工厂方法模式"},{"content":"背景 为了保证各个年龄段祖国花朵的健康成长，我们在国内的流媒体平台上看到的影视资源都是经过美化的，都有着不亚于新闻联播的祥和画面。然，纵使风景这边独好，有的时候我们依然要带着批判的眼光，去看、去听、去感受外面世界的险恶与残酷，以便解救西方世界的人名群众于水火，实现人类大同的理想\u0026hellip;\u0026hellip;\n额咳咳，扯远了。总之，大部分人搭建 NAS 的初衷，可能都是更方便的管理影视剧资源。对于喜欢看动漫的人，可能还希望可以每周同步下载最新的番剧，因此，在这里介绍一套基于 Sonarr 等软件的影音资源管理系统，主要实现了以下功能：\n自动下载最新的番剧、电影、电视剧等资源 影视资源的分类管理 搜刮资源信息 多端播放 整体架构 平台信息 本人使用的是 Unraid 系统，因此接下来都以 Unraid 为例。所有的服务都是使用 Docker 容器的方式运行，对于支持 Docker 的系统，都可以参考本文的配置进行相应的修改。\n系统组成 Sonarr：番剧下载管理，支持动漫、电视剧的搜索和下载 Radarr：电影下载管理，支持电影的搜索和下载 Overseerr：媒体请求管理，更现代化的 Web 界面 Jackett：资源搜刮，提供各种资源站点的搜索接口，Sonarr、Radarr 通过它来搜索资源 （可选）FlareSolverr：解决 Cloudflare 验证问题，提高 Jackett 的资源搜刮成功率 qBittorrent：下载器 Plex：媒体服务器 （可选）JProxy：Sonarr、Radarr 与 Jackett 之间的代理，优化资源匹配结果 安装配置 安装 Docker Unraid 系统默认已经安装了 Docker。如果是其他系统或平台，可参考各自的官方文档进行安装，或者参考 Docker 官方文档 进行手动安装。\n目录准备 为了实现各个服务之间的交互和数据共享，需要提前对可能使用的目录进行规划。以 Unraid 为例，使用到的目录如下：\n/mnt/user/appdata：Docker 容器的配置文件目录，各服务涉及到服务本身的配置，统一扔在这里 /mnt/user/media/movies：电影媒体库目录 Radarr 使用此目录作为电影媒体库目录 /mnt/user/media/tv：电视剧媒体库目录 Sonarr 使用此目录作为影视剧媒体库目录 /mnt/user/media/anime：动漫媒体库目录 Sonarr 使用此目录作为动漫媒体库目录 /mnt/user/media/downloads：下载目录 qBittorrent 使用此目录作为下载目录 Sonarr、Radarr 从此目录读取数据，并移动到相应的媒体库目录 如果创建 Docker 服务时以上目录没有自动创建，可以提前手工创建。\nqBittorrent qBittorrent 作为下载器，不主动依赖与其他的服务，因此作为我们安装的起始。安装时，需要注意以下几点：\n如上述的目录规划，容器的 /downloads 目录需要映射到 /mnt/user/media/downloads 目录 默认的端口可以不做修改，为了保证 P2P 下载效果，6881 端口需要在路由器侧配置端口转发 默认的用户名为 admin，密码为 adminadmin，安装完成后，建议修改密码 如果 qBittorrent 版本在 4.6.1.0 以上，默认密码不再是 adminadmin，而是一个随机生成的密码，在容器启动过程中会打印出来，需要注意保存 强烈建议修改默认的用户名和密码，避免被他人利用 启动服务后，还可以进行一些额外的配置\n为了提升下载速度，可以在配置中添加 Tracker 服务器，我使用的是 XIU2 提供的 TrackerListCollection 根据网络设施的情况，可以在配置中开启 DHT、PEX、LSD 等功能，提升下载速度 根据网络的使用时间，可以在配置中设置下载速度限制，避免影响其他网络使用者的体验 Jackett Jackett 作为资源搜刮服务，负责搜索在 Sonarr 和 Radarr 上添加的媒体信息。由于需要在 Sonarr 和 Radarr 中配置 Jackett 的 API，因此可以优先安装 Jackett。\n安装时，将 /downloads 目录映射到 /mnt/user/media/downloads 即可，其余可使用默认配置。\n打开 Jackett 页面后，由三部分内容需要重点关注：\nAPI Key：Jackett 的 API Key，后续需要在 Sonarr 和 Radarr 中配置 Torznab Feed：Jackett 的搜索接口，后续需要在 Sonarr 和 Radarr 中配置 Add Indexer：Jackett 支持的资源站点，可以根据自己的需求添加 （可选）FlareSolverr 部分资源站使用 Cloudflare 进行验证，Jackett 无法直接在此类站点上搜索资源，此时就需要使用 FlareSolverr 是解决 Cloudflare 验证问题。\n安装过程比较简单，使用默认配置即可。安装完成后，需要在 Jackett 中配置 FlareSolverr API URL 为 FlareSolverr 的地址。\nSonarr 和 Radarr Sonarr 和 Radarr 的配置过程基本一致，因此一起进行说明。\n安装过程重点需要注意路径映射：\nSonarr /downloads：Sonarr 的下载目录，映射到 /mnt/user/media/downloads /media：Sonarr 的总媒体库目录，映射到 /mnt/user/media /tv：Sonarr 的影视剧媒体库目录，映射到 /mnt/user/media/tv Radarr /downloads：Radarr 的下载目录，映射到 /mnt/user/media/downloads /movies：Radarr 的电影媒体库目录，映射到 /mnt/user/media/movies 服务启动后，需要为 Sonarr 和 Radarr 配置搜刮器（Indexer）和下载器（Download Client），这里以 Sonarr 为例。\n配置搜刮器 Sonarr 支持多种搜刮器，包括 RSS、Torznab、Usenet 等，这里以 Torznab 为例。\n在 Settings -\u0026gt; Indexers 中，点击 + 添加一个新的搜刮器，选择 Torznab，输入以下信息：\nName：搜刮器名称，随意 Enable RSS Sync：是否启用 RSS 搜刮 Enable Search：是否启用搜索搜刮 URL：Jackett 的 Torznab Feed，格式为 http://\u0026lt;Jackett IP\u0026gt;:9117/api/v2.0/indexers/\u0026lt;Jackett API Key\u0026gt;/results/torznab/ API Key：Jackett 的 API Key Categories：搜刮的资源类型，可以根据自己的需求进行配置 Anime Categories：动漫的资源类型，可以根据自己的需求进行配置 Tags：标签，可选。如果需要在 Sonarr 中对不同的搜刮器进行区分，可以在这里配置标签 配置完成后，点击 Test 按钮，测试搜刮器是否配置成功。\n配置下载器 Sonarr 支持多种下载器，包括 Transmission、qBittorrent、Usenet 等，这里以我们安装好的 qBittorrent 为例。\n在 Settings -\u0026gt; Download Client 中，点击 + 添加一个新的下载器，选择 qBittorrent，输入以下信息：\nName：下载器名称，随意 Enable：是否启用 Host：qBittorrent 的 IP 地址 Port：qBittorrent 的端口，如果是在本机上，可以直接使用 8080 Username：qBittorrent 的用户名，如果没有修改过，可以使用 admin Password：qBittorrent 的密码 配置完成后，点击 Test 按钮，测试下载器是否配置成功。\nRadarr 的下载器配置与 Sonarr 类似，这里不再赘述。\n配置媒体库 我们想要管理影视剧、动漫、电影这三类资源，因此可以在 Sonarr 中配置三个媒体库，分别对应不同的目录。\n在 Settings -\u0026gt; Media Management 中，修改 Root Folder 的值，点击 Add Root Folder 添加一个新的媒体库，输入以下信息：\n/media/tv：影视剧媒体库目录 /media/anime：动漫媒体库目录 /media/movies：电影媒体库目录（注：此项在 Radarr 中配置） 配置 Language Profile 为了保证下载到的资源是中文的，还需要在 Sonarr 中配置 Language Profile。\n在 Settings -\u0026gt; Profiles 中，点击 + 添加一个新的 Language Profile，输入以下信息：\nName：自定义名称，如 Chinese Language：勾选 Chinese 即可 如果有其他语言的需求，可以根据自己的需求进行配置。\n使用说明 至此，Sonarr 和 Radarr 的基本配置已经完成，可以开始添加媒体信息了。\n点击顶部搜索栏，直接输入剧集名字添加即可，Sonarr 和 Radarr 会自动搜索资源并下载。\nPlex Media Server Plex Media Server 作为媒体服务器，负责将下载好的资源进行分类管理，并提供多端播放的功能。\n安装过程中，需要配置如下路径映射：\n/transcode：Plex 的转码目录，映射到 /mnt/user/appdata/plex/transcode /media：Plex 的媒体库目录，映射到 /mnt/user/media Plex 默认的端口为 32400。\n为了实现影视资源的分类管理，我们需要配置如下三个资料库：\nMovies：电影媒体库 添加资料库时，选择 电影 类型 添加文件夹，找到 /media/movies 目录 TV：电视剧媒体库 添加资料库时，选择 电视节目 类型 添加文件夹，找到 /media/tv 目录 Anime：动漫媒体库 添加资料库时，选择 电视节目 类型 添加文件夹，找到 /media/anime 目录 完成后，Plex 会自动扫描目录，将媒体信息添加到资料库中。\nPlex 会自动抓取媒体信息，包括海报、简介等，如果抓取的信息不满意，可以手动修改。至此，一个漂亮的海报墙就展示在了我们的面前。\n（可选）JProxy 这里要简单说一下 Sonarr 和 Radarr 的运行原理。Sonarr 和 Radarr 会使用本地影视剧的名字，到搜刮器中搜索资源，如果搜刮器中有匹配的资源，就会将资源添加到下载器中进行下载。然后，有时剧集的名字包含一些特殊字符，或者翻译名字和原名不一致，甚至资源站中发布的名字与原名有误，这些都会导致 Sonarr 和 Radarr 搜刮不到资源。Sonarr 和 Radarr 也不支持别名的功能，导致很多时候，明明在资源站中存在的资源，却无法被 Sonarr 和 Radarr 搜刮到。\n为了提升搜刮的成功率，我们可以使用 JProxy 作为 Sonarr 和 Radarr 与 Jackett 之间的代理，JProxy 会对 Sonarr 和 Radarr 发送的请求进行处理，将特殊字符进行转义，然后再发送给 Jackett 进行搜索。\n在 JProxy 的 Github 仓库中，有其详细的使用说明，这里不做赘述。\n由于 Unraid 的镜像仓库中没有 JProxy 的镜像，因此需要手动启动，在这里贴作者给出启动命令：\n1 2 3 4 5 6 7 8 9 docker run --name jproxy \\ --restart unless-stopped \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Asia/Shanghai \\ -e JAVA_OPTS=\u0026#34;-Xms512m -Xmx512m\u0026#34; \\ -p 8117:8117 \\ -v /docker/jproxy/database:/app/database \\ -d luckypuppy514/jproxy:latest 亲测使用 JProxy 后，搜刮的成功率确实有明显提升，强烈建议使用，并去作者的仓库中进行 star。\n（可选）Overseerr 有了 Sonarr 和 Radarr 后，可以方便的下载影视剧信息，但是对于不同类型的资源，需要在两个平台分别进行管理。为了解决这个问题，可以通过 Overseerr 来统一管理。\nPS：Overseerr 也提供了更现代化的 Web 界面，颜值党不可错过。\n配置上没有什么需要注意的。\n安装好后，使用 Plex 登录，在 Settings -\u0026gt; Media Servers 中，添加 Sonarr 和 Radarr 的 API 即可。\n总结 至此，我们的影音下载系统就搭建完成了。然而由于 BT 下载本身的特殊性，并非所有的资源都可以下载到，想要拥有完善的资源库，依然需要付出足够的努力。\n同时，此系统中还有一些问题尚待解决，比如：\n如何实现自动下载字幕 如何下载同一个字幕组的资源 能否借助 AI 的能力，实现更高级的功能： 高清化视频 自动生成字幕 这些问题就留给后续的更新中去解决了。\n额外的吐槽 折腾 NAS 确实是很有趣的事情，然而看到 NAS 里面几个 TB 的资源，很多下载了后却从未打开，仿佛跟书架上那些买了但是没看的书、Steam 库里下都没下过的游戏一起，谴责着对资源的浪费，以及没有足够多个人时间的悲哀。\n","date":"2023-12-09T23:16:35+08:00","permalink":"https://loveorange.github.io/posts/nas/nas-auto-download-media/","title":"NAS 影音下载系统配置"}]