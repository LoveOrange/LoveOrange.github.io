<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sliding-Window on Linsama&#39;s Blog</title>
    <link>http://localhost:62448/tags/sliding-window/</link>
    <description>Recent content in Sliding-Window on Linsama&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Mar 2024 20:55:41 +0800</lastBuildDate>
    <atom:link href="http://localhost:62448/tags/sliding-window/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 403. 青蛙过河</title>
      <link>http://localhost:62448/posts/leetcode/frog-jump/</link>
      <pubDate>Thu, 14 Mar 2024 20:55:41 +0800</pubDate>
      <guid>http://localhost:62448/posts/leetcode/frog-jump/</guid>
      <description>&lt;h2 id=&#34;1-题目介绍&#34;&gt;1. 题目介绍&lt;/h2&gt;&#xA;&lt;p&gt;原题链接：&lt;a href=&#34;https://leetcode.cn/problems/frog-jump/&#34;&gt;403. 青蛙过河&lt;/a&gt;，难度：&lt;strong&gt;Hard&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;一只青蛙想要过河。假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。青蛙可以跳上石子，但是不可以跳入水中。&lt;/p&gt;&#xA;&lt;p&gt;给你石子的位置列表  &lt;code&gt;stones&lt;/code&gt;（用单元格序号  &lt;strong&gt;升序&lt;/strong&gt;  表示），  请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时，  青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃  &lt;code&gt;1&lt;/code&gt;  个单位（即只能从单元格 1 跳至单元格 2 ）。&lt;/p&gt;&#xA;&lt;p&gt;如果青蛙上一步跳跃了  &lt;code&gt;k&lt;/code&gt;  个单位，那么它接下来的跳跃距离只能选择为  &lt;code&gt;k - 1&lt;/code&gt;、&lt;code&gt;k&lt;/code&gt;  或  &lt;code&gt;k + 1&lt;/code&gt;  个单位。  另请注意，青蛙只能向前方（终点的方向）跳跃。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;对我个人有很深意义的一道题，很久之前面试微软时遇到的题，结果时隔多年我忘记怎么做了&amp;hellip;&amp;hellip;&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-问题分析&#34;&gt;2. 问题分析&lt;/h2&gt;&#xA;&lt;p&gt;首先想到的是能不能通过穷举列出所有的可能性，然后发现穷举起来也挺麻烦的，难度可能不亚于想一个更靠谱的算法了，那么继续试试其他的路子。&lt;/p&gt;&#xA;&lt;p&gt;能否跳到最终的石头，取决于能否跳到上一个石头的步数 &lt;code&gt;k&lt;/code&gt;，能否恰好在 &lt;code&gt;[k - 1, k + 1]&lt;/code&gt; 之间；那能否跳到上一个石头，取决于&amp;hellip;&amp;hellip;于是我们闻到了一丝动态规划的味道。&lt;/p&gt;&#xA;&lt;p&gt;因为这是一只遗忘了游泳的青蛙，只能挑到石头上，并且每次跳只能是 &lt;code&gt;k&lt;/code&gt; 个单位，那我们从两个方向考虑：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;青蛙起跳时，如果上一次跳跃了 &lt;code&gt;k&lt;/code&gt; 个位置来到了当前位置 &lt;code&gt;i&lt;/code&gt; ，那么下一次跳跃只能跳到 &lt;code&gt;i + k - 1&lt;/code&gt;、&lt;code&gt;i + k&lt;/code&gt;、&lt;code&gt;i + k + 1&lt;/code&gt; 这三个位置，如果目的位置有石头的话，我们就可以晚一点想象这只可怜的青蛙溺水的样子。简单来说就是&lt;strong&gt;从当前位置，可以跳到哪里&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;青蛙跳到了某个石头 &lt;code&gt;i&lt;/code&gt; 时，如果知道了上次起跳的石头位置 &lt;code&gt;j&lt;/code&gt;，那么显然上次跳跃的距离为 &lt;code&gt;k = i - j&lt;/code&gt;。如果我们知道了所有能跳到当前石头 &lt;code&gt;i&lt;/code&gt; 的距离 &lt;code&gt;k&lt;/code&gt;，那么我们可以根据上一步酸楚青蛙能够跳到的下一个石头的位置。也就是&lt;strong&gt;从哪里能够跳到当前位置&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;结合这两点，我们发现需要维护一个重要的信息：&lt;strong&gt;从位置 &lt;code&gt;i&lt;/code&gt; 能否跳跃到 &lt;code&gt;j&lt;/code&gt;&lt;/strong&gt;。这也是这道题的关键，能否想到使用一个二维数组，通过 &lt;code&gt;dp[i][j]&lt;/code&gt; 的方式来表示能否从位置 &lt;code&gt;i&lt;/code&gt; 跳到 &lt;code&gt;j&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 239. 滑动窗口最大值</title>
      <link>http://localhost:62448/posts/leetcode/sliding-window-maximum/</link>
      <pubDate>Wed, 13 Mar 2024 09:46:47 +0800</pubDate>
      <guid>http://localhost:62448/posts/leetcode/sliding-window-maximum/</guid>
      <description>&lt;h2 id=&#34;1-题目介绍&#34;&gt;1. 题目介绍&lt;/h2&gt;&#xA;&lt;p&gt;原题链接：&lt;a href=&#34;https://leetcode.cn/problems/sliding-window-maximum/&#34;&gt;239. 滑动窗口最大值&lt;/a&gt;，难度：&lt;strong&gt;Hard&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;给你一个整数数组  &lt;code&gt;nums&lt;/code&gt;，有一个大小为  &lt;code&gt;k&lt;/code&gt;  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的  &lt;code&gt;k&lt;/code&gt;  个数字。滑动窗口每次只向右移动一位。&lt;/p&gt;&#xA;&lt;p&gt;返回  &lt;em&gt;滑动窗口中的最大值&lt;/em&gt; 。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;2-问题分析&#34;&gt;2. 问题分析&lt;/h2&gt;&#xA;&lt;p&gt;因为滑动窗口的长度为 &lt;code&gt;k&lt;/code&gt;，所以最终返回的结果是一个长度为 &lt;code&gt;nums.length - k + 1&lt;/code&gt; 的数组。如果这是大学期末考试题的话，写到这里至少应该能得两分。&lt;/p&gt;&#xA;&lt;p&gt;接下来想办法获取每 &lt;code&gt;k&lt;/code&gt; 个长度内的最大值。假设我们已经维护了 &lt;code&gt;[i, i + k)&lt;/code&gt; 个数字的数组 &lt;code&gt;arr&lt;/code&gt;，并且按照从大到小的顺序排序了。那么当索引移动到 &lt;code&gt;i + 1&lt;/code&gt; 时，我们需要做的就是将数组 &lt;code&gt;arr&lt;/code&gt; 中，按照从大到小的顺序，移除不在索引 &lt;code&gt;[i + 1， i + k + 1)&lt;/code&gt; 的数字，那么此时数组的头部元素即是当前段的最大值。&lt;/p&gt;&#xA;&lt;p&gt;考虑到数组中的数字允许重复，如果在 &lt;code&gt;[i, i + k)&lt;/code&gt; 段中，有两个最大值，那么我们优先考虑使用后面的索引，因为它更有可能在下一段中也是最大值。因此在数组 &lt;code&gt;arr&lt;/code&gt; 中，除了要维护 &lt;code&gt;[i, i + k)&lt;/code&gt; 的值外，还需要将它们对应的索引也维护起来，并且按照值大小、索引位置进行排序。&lt;/p&gt;&#xA;&lt;p&gt;为了简化排序流程，可以考虑使用「优先队列」的数据结构。初始化如下的优先队列，队列的每一个元素是一个数组，值为 &lt;code&gt;{ nums[i], i }&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ar1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;h2 id=&#34;3-代码实现&#34;&gt;3. 代码实现&lt;/h2&gt;&#xA;&lt;p&gt;最终代码如下所示：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 76. 最小覆盖子串</title>
      <link>http://localhost:62448/posts/leetcode/lc-76-minimum-window-substring/</link>
      <pubDate>Tue, 12 Mar 2024 21:53:01 +0800</pubDate>
      <guid>http://localhost:62448/posts/leetcode/lc-76-minimum-window-substring/</guid>
      <description>&lt;h2 id=&#34;1-题目介绍&#34;&gt;1. 题目介绍&lt;/h2&gt;&#xA;&lt;p&gt;原题链接：&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-window-substring/&#34;&gt;76. 最小覆盖子串&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;题目的描述很简单：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &amp;quot;&amp;quot; 。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;最小覆盖子串是很经典的面试题了，也是我 17 年面试微软的原题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-问题分析&#34;&gt;2. 问题分析&lt;/h2&gt;&#xA;&lt;p&gt;这是一个典型的滑动窗口问题，让我们来一步一步分析这道题。&lt;/p&gt;&#xA;&lt;p&gt;题目中要求找到字符串 &lt;code&gt;s&lt;/code&gt; 中涵盖字符串 &lt;code&gt;t&lt;/code&gt; 的所有字符，那么首先需要统计字符串 &lt;code&gt;t&lt;/code&gt; 中有多少字符，可以使用一个 &lt;code&gt;Map&amp;lt;Character, Integer&amp;gt; map&lt;/code&gt; 来存储 &lt;code&gt;t&lt;/code&gt; 中的字符以及出现的次数。&lt;/p&gt;&#xA;&lt;p&gt;接下来就是滑动窗口的思路，设定滑动窗口的两端 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt;，使用 &lt;code&gt;Map&amp;lt;Character, Integer&amp;gt; window&lt;/code&gt; 记录滑动窗口中的字符数量。&lt;/p&gt;&#xA;&lt;p&gt;首先不断地向前移动右边界 &lt;code&gt;right&lt;/code&gt;，直到 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 中的字符完全包含了 &lt;code&gt;map&lt;/code&gt; 中的字符。&lt;/p&gt;&#xA;&lt;p&gt;确定好右边界后，收缩左边界，同样地向前移动 &lt;code&gt;left&lt;/code&gt;，直到 &lt;code&gt;left&lt;/code&gt; 与 &lt;code&gt;right&lt;/code&gt; 中的字符不再完全包含 &lt;code&gt;map&lt;/code&gt; 中的字符，则左边界收缩结束。&lt;/p&gt;&#xA;&lt;p&gt;可以使用 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 记录能够完全覆盖 &lt;code&gt;map&lt;/code&gt; 中的字符时，&lt;code&gt;left&lt;/code&gt; 与 &lt;code&gt;right&lt;/code&gt; 的值。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
