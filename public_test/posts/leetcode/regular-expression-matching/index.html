<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=62448&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 10. 正则表达式匹配 | Linsama&#39;s Blog</title>
    <meta name="description" content="1. 题目介绍
原题链接：10. 正则表达式匹配，难度：Hard。

给你一个字符串  s  和一个字符规律  p，请你来实现一个支持  &#39;.&#39;  和  &#39;*&#39;  的正则表达式匹配。

&#39;.&#39;  匹配任意单个字符
&#39;*&#39;  匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖  整个  字符串  s的，而不是部分字符串。

虽然是早期的 Hard，但是这道题的难度还是很高的，尤其以这道题的代码量来说。
2. 问题分析
首先需要分析问题的类型。如果说不存在 &#39;.&#39; 和 &#39;*&#39;，字符的话，那么只要 equals() 即可了。当然这道题不会这么善良。
首先引入 &#39;.&#39; 的概念，如果除了 &#39;.&#39; 之外的字符与位置都一致，那么也可以简单的判断是否能够匹配。
最后引入 &#39;*&#39; 的概念，它会将前一个的字符重复任意次数，也就是说，需要考虑前面的字符不会出现，以及出现多次，下述几种情况前面的字符串为 s，后面的为 p：

acd 和 ab*cd：b 出现 0 次，可以匹配
abcd 和 ab*cd：b 出现 1 次，可以匹配
abcd 和 ab*bcd：b* 实际没有使用，匹配的是 p.charAt(3) 的字符 b

需要记录类似例子 3 中 b* 能够匹配的 s 的位置，因此考虑这是个 dp 问题，需要记录截止到 p 的第 j 个字符为止，能够匹配 s 的第 i 个字符。">

    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400&family=Lato:wght@300;400;700&family=Noto+Sans+SC:wght@300;400;700&family=Ma+Shan+Zheng&display=swap" rel="stylesheet">

    
    <link rel="stylesheet" href="/css/style.css">

    
    
</head>

  <body>
    <div class="site-container">
      <header class="site-header">
    <div class="logo">
        <a href="http://localhost:62448/">Linsama&#39;s Blog</a>
    </div>
    <nav class="main-nav">
        <ul>
            
            <li><a href="/">Home</a></li>
            
            <li><a href="/archives/">Archives</a></li>
            
            <li><a href="/search/">Search</a></li>
            
            <li><a href="/links/">Links</a></li>
            
        </ul>
    </nav>
</header>


      <div class="main-container single-column">
        <main class="content">
          
<article class="post-single">
    <header class="post-header">
        <h1 class="post-title">LeetCode 10. 正则表达式匹配</h1>
        <div class="post-meta">
            <span>Mar 18, 2024</span>
            
                <span class="category">in <a href="/categories/leetcode">leetcode</a> </span>
            
            <span> | 450 words</span>
        </div>
    </header>

    <div class="post-content">
        <h2 id="1-题目介绍">1. 题目介绍</h2>
<p>原题链接：<a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配</a>，难度：<strong>Hard</strong>。</p>
<blockquote>
<p>给你一个字符串  <code>s</code>  和一个字符规律  <code>p</code>，请你来实现一个支持  <code>'.'</code>  和  <code>'*'</code>  的正则表达式匹配。</p>
<ul>
<li><code>'.'</code>  匹配任意单个字符</li>
<li><code>'*'</code>  匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖  <strong>整个</strong>  字符串  <code>s</code>的，而不是部分字符串。</p>
</blockquote>
<p>虽然是早期的 Hard，但是这道题的难度还是很高的，尤其以这道题的代码量来说。</p>
<h2 id="2-问题分析">2. 问题分析</h2>
<p>首先需要分析问题的类型。如果说不存在 <code>'.'</code> 和 <code>'*'</code>，字符的话，那么只要 <code>equals()</code> 即可了。当然这道题不会这么善良。</p>
<p>首先引入 <code>'.'</code> 的概念，如果除了 <code>'.'</code> 之外的字符与位置都一致，那么也可以简单的判断是否能够匹配。</p>
<p>最后引入 <code>'*'</code> 的概念，它会将前一个的字符重复任意次数，也就是说，需要考虑前面的字符不会出现，以及出现多次，下述几种情况前面的字符串为 <code>s</code>，后面的为 <code>p</code>：</p>
<ol>
<li><code>acd</code> 和 <code>ab*cd</code>：<code>b</code> 出现 0 次，可以匹配</li>
<li><code>abcd</code> 和 <code>ab*cd</code>：b 出现 1 次，可以匹配</li>
<li><code>abcd</code> 和 <code>ab*bcd</code>：<code>b*</code> 实际没有使用，匹配的是 <code>p.charAt(3)</code> 的字符 <code>b</code></li>
</ol>
<p>需要记录类似例子 3 中 <code>b*</code> 能够匹配的 <code>s</code> 的位置，因此考虑这是个 dp 问题，需要记录截止到 <code>p</code> 的第 <code>j</code> 个字符为止，能够匹配 <code>s</code> 的第 <code>i</code> 个字符。</p>
<p>接下来考虑状态转移方程。对于没有 <code>'*'</code> 的世界来说，仅需要判断两种情况：</p>
<ol>
<li><code>s.charAt(i) == p.charAt(j)</code></li>
<li><code>p.chatAt(j) == '.'</code>
显然状态转移方程为 <code>dp[i][j] = dp[i - 1][j - 1] &amp; {上述两种情况}</code>。</li>
</ol>
<p>复杂性同样在引入了 <code>'*'</code> 的世界里。还需要考虑以下三种情况：</p>
<ol>
<li>如果不使用 <code>'*'</code> 以及它前面的字符，那么存在 <code>dp[i][j] = dp[i - 1][j - 2]</code></li>
<li>如果使用 <code>'*'</code> 以及它前面的字符，则有：
<ol>
<li>当 <code>s.charAt(i) == p.charAt(j - 1)</code> 或者 <code>p.charAt(j - 1) == '.'</code> 时，即 <code>s</code> 的第 <code>i</code> 个字符与 <code>p</code> 的 <code>j - 1</code>（<code>'*'</code> 前的字符）一致时，<code>dp[i][j] = dp[i - 1][j]</code>，与 <code>dp[i - 1][j]</code> 比较的原因是，可以想象成 <code>dp[i - 1][j]</code> 中的 <code>'*'</code> 与其前置字符没有被使用</li>
<li>上述判断不成立，返回 <code>false</code></li>
</ol>
</li>
</ol>
<p>为此，我们大概可以总结出了状态转移方程。</p>
<p>还需要考虑的特殊情况是，当 <code>s</code> 或者 <code>p</code> 为空串的场景，为了简化这种场景，我们初始化 <code>dp</code> 数组时，使用 <code>boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]</code> 来初始化。考虑到 <code>p</code> 的第一个字符不会是 <code>'*'</code>，那么只要 <code>s</code> 为空串时，除了 <code>p</code> 也为空串的场景，都无法进行匹配。</p>
<h2 id="3-代码实现">3. 代码实现</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isMatch</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="na">length</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 因为使用 m + 1 与 n + 1 进行初始化，</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 后续使用 .charAt 时，需要将 i j 减 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="o">[][]</span><span class="w"> </span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 空串可以互相匹配</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// 先考虑没有 &#39;*&#39; 的世界</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;*&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 引入 &#39;*&#39; 后，先考虑不使用 &#39;*&#39; 与前置字符</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">2</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 如果 s.charAt(i - 1) == p.charAt(i - 2)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 即当前遍历的 s 的字符，与 p 中 * 前的字符相同</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isMatch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="c1">// 那么 s 直到 i - 1 与 p 直到 j - 1 能否匹配，</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="c1">// 取决于 dp[i][j - 2] 与 dp[i - 1][j] 的结果</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">isMatch</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">si</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pi</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">si</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">pi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">si</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">pi</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="4-一些总结">4. 一些总结</h2>
<p>这道题的难点我觉得有两个，第一个是想到动态规划的解法，我最开始想用回溯来做，发现需要考虑的场景很多，然后无情的看了答案；第二个是找出状态转移方程，需要考虑引入了 <code>*</code> 之后，是否使用 <code>*</code> 与前置字符，从而得出 <code>dp[i][j] = dp[i][j - 2] || dp[i - 1][j]</code> 这一步。想到这两点后，额外需要注意的就是考虑空串的情况了。</p>
<p>总觉得几个月后再看这道题，还是会忘&hellip;&hellip;</p>

    </div>

    <footer class="post-footer">
        
        <div class="post-tags">
            Tags:
            
            <a href="/tags/leetcode">#leetcode</a>
            
            <a href="/tags/oa">#oa</a>
            
        </div>
        
    </footer>
</article>

        </main>

        
      </div>

      <footer class="site-footer">
    <p>&copy; 2026 Linsama&#39;s Blog. All rights reserved.</p>
    <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> & <a href="#">Wabi-Sabi</a></p>
</footer>

    </div>
  </body>
</html>
