<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=62448&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 403. 青蛙过河 | Linsama&#39;s Blog</title>
    <meta name="description" content="1. 题目介绍
原题链接：403. 青蛙过河，难度：Hard。

一只青蛙想要过河。假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。青蛙可以跳上石子，但是不可以跳入水中。
给你石子的位置列表  stones（用单元格序号  升序  表示），  请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时，  青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃  1  个单位（即只能从单元格 1 跳至单元格 2 ）。
如果青蛙上一步跳跃了  k  个单位，那么它接下来的跳跃距离只能选择为  k - 1、k  或  k &#43; 1  个单位。  另请注意，青蛙只能向前方（终点的方向）跳跃。

对我个人有很深意义的一道题，很久之前面试微软时遇到的题，结果时隔多年我忘记怎么做了&hellip;&hellip;
2. 问题分析
首先想到的是能不能通过穷举列出所有的可能性，然后发现穷举起来也挺麻烦的，难度可能不亚于想一个更靠谱的算法了，那么继续试试其他的路子。
能否跳到最终的石头，取决于能否跳到上一个石头的步数 k，能否恰好在 [k - 1, k &#43; 1] 之间；那能否跳到上一个石头，取决于&hellip;&hellip;于是我们闻到了一丝动态规划的味道。
因为这是一只遗忘了游泳的青蛙，只能挑到石头上，并且每次跳只能是 k 个单位，那我们从两个方向考虑：

青蛙起跳时，如果上一次跳跃了 k 个位置来到了当前位置 i ，那么下一次跳跃只能跳到 i &#43; k - 1、i &#43; k、i &#43; k &#43; 1 这三个位置，如果目的位置有石头的话，我们就可以晚一点想象这只可怜的青蛙溺水的样子。简单来说就是从当前位置，可以跳到哪里。
青蛙跳到了某个石头 i 时，如果知道了上次起跳的石头位置 j，那么显然上次跳跃的距离为 k = i - j。如果我们知道了所有能跳到当前石头 i 的距离 k，那么我们可以根据上一步酸楚青蛙能够跳到的下一个石头的位置。也就是从哪里能够跳到当前位置

结合这两点，我们发现需要维护一个重要的信息：从位置 i 能否跳跃到 j。这也是这道题的关键，能否想到使用一个二维数组，通过 dp[i][j] 的方式来表示能否从位置 i 跳到 j。">

    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400&family=Lato:wght@300;400;700&family=Noto+Sans+SC:wght@300;400;700&family=Ma+Shan+Zheng&display=swap" rel="stylesheet">

    
    <link rel="stylesheet" href="/css/style.css">

    
    
</head>

  <body>
    <div class="site-container">
      <header class="site-header">
    <div class="logo">
        <a href="http://localhost:62448/">Linsama&#39;s Blog</a>
    </div>
    <nav class="main-nav">
        <ul>
            
            <li><a href="/">Home</a></li>
            
            <li><a href="/archives/">Archives</a></li>
            
            <li><a href="/search/">Search</a></li>
            
            <li><a href="/links/">Links</a></li>
            
        </ul>
    </nav>
</header>


      <div class="main-container single-column">
        <main class="content">
          
<article class="post-single">
    <header class="post-header">
        <h1 class="post-title">LeetCode 403. 青蛙过河</h1>
        <div class="post-meta">
            <span>Mar 14, 2024</span>
            
                <span class="category">in <a href="/categories/leetcode">leetcode</a> </span>
            
            <span> | 326 words</span>
        </div>
    </header>

    <div class="post-content">
        <h2 id="1-题目介绍">1. 题目介绍</h2>
<p>原题链接：<a href="https://leetcode.cn/problems/frog-jump/">403. 青蛙过河</a>，难度：<strong>Hard</strong>。</p>
<blockquote>
<p>一只青蛙想要过河。假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。青蛙可以跳上石子，但是不可以跳入水中。</p>
<p>给你石子的位置列表  <code>stones</code>（用单元格序号  <strong>升序</strong>  表示），  请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时，  青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃  <code>1</code>  个单位（即只能从单元格 1 跳至单元格 2 ）。</p>
<p>如果青蛙上一步跳跃了  <code>k</code>  个单位，那么它接下来的跳跃距离只能选择为  <code>k - 1</code>、<code>k</code>  或  <code>k + 1</code>  个单位。  另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
</blockquote>
<p>对我个人有很深意义的一道题，很久之前面试微软时遇到的题，结果时隔多年我忘记怎么做了&hellip;&hellip;</p>
<h2 id="2-问题分析">2. 问题分析</h2>
<p>首先想到的是能不能通过穷举列出所有的可能性，然后发现穷举起来也挺麻烦的，难度可能不亚于想一个更靠谱的算法了，那么继续试试其他的路子。</p>
<p>能否跳到最终的石头，取决于能否跳到上一个石头的步数 <code>k</code>，能否恰好在 <code>[k - 1, k + 1]</code> 之间；那能否跳到上一个石头，取决于&hellip;&hellip;于是我们闻到了一丝动态规划的味道。</p>
<p>因为这是一只遗忘了游泳的青蛙，只能挑到石头上，并且每次跳只能是 <code>k</code> 个单位，那我们从两个方向考虑：</p>
<ol>
<li>青蛙起跳时，如果上一次跳跃了 <code>k</code> 个位置来到了当前位置 <code>i</code> ，那么下一次跳跃只能跳到 <code>i + k - 1</code>、<code>i + k</code>、<code>i + k + 1</code> 这三个位置，如果目的位置有石头的话，我们就可以晚一点想象这只可怜的青蛙溺水的样子。简单来说就是<strong>从当前位置，可以跳到哪里</strong>。</li>
<li>青蛙跳到了某个石头 <code>i</code> 时，如果知道了上次起跳的石头位置 <code>j</code>，那么显然上次跳跃的距离为 <code>k = i - j</code>。如果我们知道了所有能跳到当前石头 <code>i</code> 的距离 <code>k</code>，那么我们可以根据上一步酸楚青蛙能够跳到的下一个石头的位置。也就是<strong>从哪里能够跳到当前位置</strong></li>
</ol>
<p>结合这两点，我们发现需要维护一个重要的信息：<strong>从位置 <code>i</code> 能否跳跃到 <code>j</code></strong>。这也是这道题的关键，能否想到使用一个二维数组，通过 <code>dp[i][j]</code> 的方式来表示能否从位置 <code>i</code> 跳到 <code>j</code>。</p>
<p>有了 <code>dp[i][j]</code> 之后，只需要遍历石头的位置，每次跳到位置 <code>j</code> 时，找到所有能跳到 <code>j</code> 的位置 <code>i</code>，记录下跳跃的距离，再分别记录能跳跃到的目标位置 <code>j + k - 1</code>、<code>j + k</code>、<code>j + k + 1</code> 是否有石头即可。</p>
<p>如果发现恰好能挑到最后一块石头，即可结束遍历。</p>
<p>有一些可以减少内存占用的优化。根据题目给出的数据范围，石块的位置可能远大于石块的数量， 可以使 <code>dp[i][j]</code> 中的 <code>i</code> 和 <code>j</code> 分别表示石块在 <code>stones</code> 的索引。另外只需要记录能否从 <code>i</code> 跳到 <code>j</code> 即可，<code>dp[i][j]</code> 可以使用 <code>boolean</code> 来表示。</p>
<h2 id="3-代码实现">3. 代码实现</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">canCross</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">stones</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stones</span><span class="p">.</span><span class="na">length</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">stones</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="o">[][]</span><span class="w"> </span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dp</span><span class="o">[</span><span class="n">0</span><span class="o">][</span><span class="n">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stones</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">stones</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stones</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="n">next</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">next</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="n">next</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">next</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="na">containsKey</span><span class="p">(</span><span class="n">next</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 可以在上面的 for 循环中判断是否到达终点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 但是我不想破坏上面整齐的结构</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">1</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="4-一点吐槽">4. 一点吐槽</h2>
<p>这是青蛙唉，会游泳的，不管它跳不跳石头，它都能过河的撒。我觉得这道题的解就应该是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Solution</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">canCross</span><span class="p">(</span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">stones</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 如果青蛙过不去，那就只能说是它不想过去</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <footer class="post-footer">
        
        <div class="post-tags">
            Tags:
            
            <a href="/tags/leetcode">#leetcode</a>
            
            <a href="/tags/oa">#oa</a>
            
            <a href="/tags/sliding-window">#sliding-window</a>
            
        </div>
        
    </footer>
</article>

        </main>

        
      </div>

      <footer class="site-footer">
    <p>&copy; 2026 Linsama&#39;s Blog. All rights reserved.</p>
    <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> & <a href="#">Wabi-Sabi</a></p>
</footer>

    </div>
  </body>
</html>
